nuee_rda <- nuee$rda(varespec_py, formula = "~ N + P + K + Ca + Mg", data = varechem_py)
vegan_rda <- vegan::rda(varespec_mat, env_matrix)
nuee_rda_eig <- as.numeric(py_to_r(nuee_rda$constrained_eig))
vegan_rda_eig <- as.numeric(vegan_rda$CCA$eig)
test_that("RDA eigenvalues comparable", {
expect_equal(nuee_rda_eig[seq_along(vegan_rda_eig)], vegan_rda_eig, tolerance = 5e-2)
})
test_that("RDA constrained axes available", {
expect_gte(ncol(as.matrix(py_to_r(nuee_rda$points))), length(vegan_rda_eig))
})
for (scaling in 1:3) {
nuee_sites <- as.matrix(py_to_r(nuee_rda$get_scores(display = "sites", scaling = scaling)))
vegan_sites <- vegan::scores(vegan_rda, display = "sites", scaling = scaling)
n_axes <- ncol(vegan_sites)
test_that(paste0("RDA site scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_sites[, seq_len(n_axes), drop = FALSE], vegan_sites, tolerance = 1e-1)
})
nuee_species <- as.matrix(py_to_r(nuee_rda$get_scores(display = "species", scaling = scaling)))
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
test_that(paste0("RDA species scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_species[, seq_len(n_axes), drop = FALSE], vegan_species, tolerance = 1e-1)
})
}
nuee_species[, seq_len(n_axes), drop = FALSE]
vegan_species
for (scaling in 1:3) {
nuee_sites <- as.matrix(py_to_r(nuee_rda$get_scores(display = "sites", scaling = scaling)))
vegan_sites <- vegan::scores(vegan_rda, display = "sites", scaling = scaling)
n_axes <- ncol(vegan_sites)
test_that(paste0("RDA site scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_sites[, seq_len(n_axes), drop = FALSE], vegan_sites, tolerance = 1e-1)
})
nuee_species <- as.matrix(py_to_r(nuee_rda$get_scores(display = "species", scaling = scaling)))
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
test_that(paste0("RDA species scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_species[, seq_len(n_axes), drop = FALSE], vegan_species, tolerance = 1e-1)
})
}
nuee_species[, seq_len(n_axes), drop = FALSE][, 1:5]
vegan_species[, 1:5]
nuee_species[, seq_len(n_axes), drop = FALSE][1:5]
nuee_species[, seq_len(n_axes), drop = FALSE][1:5, ]
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
for (scaling in 1:3) {
nuee_sites <- as.matrix(py_to_r(nuee_rda$get_scores(display = "sites", scaling = scaling)))
vegan_sites <- vegan::scores(vegan_rda, display = "sites", scaling = scaling)
n_axes <- ncol(vegan_sites)
test_that(paste0("RDA site scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_sites[, seq_len(n_axes), drop = FALSE], vegan_sites, tolerance = 1e-1)
})
nuee_species <- as.matrix(py_to_r(nuee_rda$get_scores(display = "species", scaling = scaling)))
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
test_that(paste0("RDA species scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_species[, seq_len(n_axes), drop = FALSE], vegan_species, tolerance = 1e-1)
})
}
nuee_species[, seq_len(n_axes), drop = FALSE][1:5, ]
vegan_species[1:5, ]
library(reticulate)
library(vegan)
library(testthat)
setwd("C:/Users/parse01/documents-locaux/GitHub/nuee")
use_python(".venv/Scripts/python.exe", required = TRUE)
py_config()
# -- Load data from both ecosystems ------------------------------------------------
nuee <- import("nuee")
varespec_py <- nuee$datasets$varespec()
varespec_r  <- py_to_r(varespec_py)
# -- Run nuee metaMDS --------------------------------------------------------------
nuee_res <- nuee$metaMDS(varespec_py, k = as.integer(2), distance = "bray")
nuee_history   <- py_to_r(nuee_res$stress_history)
nuee_runs      <- vapply(nuee_history, `[[`, numeric(1), "stress")
nuee_stress    <- py_to_r(nuee_res$stress)
nuee_converged <- py_to_r(nuee_res$converged)
nuee_points    <- as.matrix(py_to_r(nuee_res$points))
nuee_species   <- py_to_r(nuee_res$species)
if (!is.null(nuee_species)) {
nuee_species <- as.matrix(nuee_species)
}
# -- Run vegan metaMDS and capture run trace --------------------------------------
trace_lines <- capture.output(
vegan_res <- vegan::metaMDS(
as.matrix(varespec_r),
k        = 2,
distance = "bray",
trymax   = 20,
trace    = TRUE
)
)
run_lines <- grep("^Run", trace_lines, value = TRUE)
vegan_history <- as.numeric(sub(".*stress\\s+([0-9.]+).*", "\\1", run_lines))
vegan_history <- vegan_history[-1]  # drop Run 0 (initial configuration)
vegan_stress  <- vegan_res$stress
vegan_points  <- as.matrix(vegan_res$points)
vegan_species <- as.matrix(vegan_res$species)
# -- Tests ------------------------------------------------------------------------
test_that("metaMDS reports convergence", {
expect_true(nuee_converged)
})
test_that("best stress comparable", {
expect_lte(abs(nuee_stress - min(vegan_history)), 5e-2)
expect_lte(abs(nuee_stress - vegan_stress), 5e-2)
})
test_that("stress history lengths match", {
expect_equal(length(nuee_runs), length(vegan_history))
})
test_that("ordination output shapes match", {
expect_equal(dim(nuee_points), dim(vegan_points))
if (!is.null(nuee_species)) {
expect_equal(dim(nuee_species), dim(vegan_species))
}
})
# -- Diversity metrics ------------------------------------------------------------
bci_py <- nuee$datasets$BCI()
bci_r  <- py_to_r(bci_py)
bci_mat <- as.matrix(bci_r)
nuee_shannon <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "shannon")))
vegan_shannon <- vegan::diversity(bci_mat, index = "shannon")
nuee_simpson <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "simpson")))
vegan_simpson <- vegan::diversity(bci_mat, index = "simpson")
nuee_invsimpson <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "invsimpson")))
vegan_invsimpson <- vegan::diversity(bci_mat, index = "invsimpson")
spec_py <- nuee$specnumber(bci_py)
nuee_specnumber <- as.numeric(py_to_r(spec_py$values))
vegan_specnumber <- vegan::specnumber(bci_mat)
test_that("diversity metrics match vegan", {
expect_equal(unname(nuee_shannon), unname(vegan_shannon), tolerance = 1e-6)
expect_equal(unname(nuee_simpson), unname(vegan_simpson), tolerance = 1e-6)
expect_equal(unname(nuee_invsimpson), unname(vegan_invsimpson), tolerance = 1e-6)
})
test_that("species richness matches vegan", {
expect_equal(unname(nuee_specnumber), unname(vegan_specnumber))
})
# -- Distance metrics -------------------------------------------------------------
nuee_dist <- py_to_r(nuee$vegdist(bci_py, method = "bray"))
vegan_dist <- as.matrix(vegan::vegdist(bci_mat, method = "bray"))
test_that("Bray-Curtis distances match vegan", {
expect_equal(unname(nuee_dist), unname(vegan_dist), tolerance = 1e-6)
})
# -- Constrained ordination: RDA --------------------------------------------------
varespec_mat <- as.matrix(varespec_r)
varechem_py  <- nuee$datasets$varechem()
varechem_r   <- py_to_r(varechem_py)
varechem_df  <- as.data.frame(varechem_r)
env_vars <- c("N", "P", "K", "Ca", "Mg")
env_matrix <- as.matrix(varechem_df[, env_vars])
nuee_rda <- nuee$rda(varespec_py, formula = "~ N + P + K + Ca + Mg", data = varechem_py)
vegan_rda <- vegan::rda(varespec_mat, env_matrix)
nuee_rda_eig <- as.numeric(py_to_r(nuee_rda$constrained_eig))
vegan_rda_eig <- as.numeric(vegan_rda$CCA$eig)
test_that("RDA eigenvalues comparable", {
expect_equal(nuee_rda_eig[seq_along(vegan_rda_eig)], vegan_rda_eig, tolerance = 5e-2)
})
test_that("RDA constrained axes available", {
expect_gte(ncol(as.matrix(py_to_r(nuee_rda$points))), length(vegan_rda_eig))
})
for (scaling in 1:3) {
nuee_sites <- as.matrix(py_to_r(nuee_rda$get_scores(display = "sites", scaling = scaling)))
vegan_sites <- vegan::scores(vegan_rda, display = "sites", scaling = scaling)
n_axes <- ncol(vegan_sites)
test_that(paste0("RDA site scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_sites[, seq_len(n_axes), drop = FALSE], vegan_sites, tolerance = 1e-1)
})
nuee_species <- as.matrix(py_to_r(nuee_rda$get_scores(display = "species", scaling = scaling)))
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
test_that(paste0("RDA species scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_species[, seq_len(n_axes), drop = FALSE], vegan_species, tolerance = 1e-1)
})
}
nuee_species[, seq_len(n_axes), drop = FALSE][1:5, ]
vegan_species[1:5, ]
library(reticulate)
library(vegan)
library(testthat)
setwd("C:/Users/parse01/documents-locaux/GitHub/nuee")
use_python(".venv/Scripts/python.exe", required = TRUE)
py_config()
# -- Load data from both ecosystems ------------------------------------------------
nuee <- import("nuee")
varespec_py <- nuee$datasets$varespec()
varespec_r  <- py_to_r(varespec_py)
# -- Run nuee metaMDS --------------------------------------------------------------
nuee_res <- nuee$metaMDS(varespec_py, k = as.integer(2), distance = "bray")
nuee_history   <- py_to_r(nuee_res$stress_history)
nuee_runs      <- vapply(nuee_history, `[[`, numeric(1), "stress")
nuee_stress    <- py_to_r(nuee_res$stress)
nuee_converged <- py_to_r(nuee_res$converged)
nuee_points    <- as.matrix(py_to_r(nuee_res$points))
nuee_species   <- py_to_r(nuee_res$species)
if (!is.null(nuee_species)) {
nuee_species <- as.matrix(nuee_species)
}
# -- Run vegan metaMDS and capture run trace --------------------------------------
trace_lines <- capture.output(
vegan_res <- vegan::metaMDS(
as.matrix(varespec_r),
k        = 2,
distance = "bray",
trymax   = 20,
trace    = TRUE
)
)
run_lines <- grep("^Run", trace_lines, value = TRUE)
vegan_history <- as.numeric(sub(".*stress\\s+([0-9.]+).*", "\\1", run_lines))
vegan_history <- vegan_history[-1]  # drop Run 0 (initial configuration)
vegan_stress  <- vegan_res$stress
vegan_points  <- as.matrix(vegan_res$points)
vegan_species <- as.matrix(vegan_res$species)
# -- Tests ------------------------------------------------------------------------
test_that("metaMDS reports convergence", {
expect_true(nuee_converged)
})
test_that("best stress comparable", {
expect_lte(abs(nuee_stress - min(vegan_history)), 5e-2)
expect_lte(abs(nuee_stress - vegan_stress), 5e-2)
})
test_that("stress history lengths match", {
expect_equal(length(nuee_runs), length(vegan_history))
})
test_that("ordination output shapes match", {
expect_equal(dim(nuee_points), dim(vegan_points))
if (!is.null(nuee_species)) {
expect_equal(dim(nuee_species), dim(vegan_species))
}
})
# -- Diversity metrics ------------------------------------------------------------
bci_py <- nuee$datasets$BCI()
bci_r  <- py_to_r(bci_py)
bci_mat <- as.matrix(bci_r)
nuee_shannon <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "shannon")))
vegan_shannon <- vegan::diversity(bci_mat, index = "shannon")
nuee_simpson <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "simpson")))
vegan_simpson <- vegan::diversity(bci_mat, index = "simpson")
nuee_invsimpson <- as.numeric(py_to_r(nuee$diversity(bci_py, index = "invsimpson")))
vegan_invsimpson <- vegan::diversity(bci_mat, index = "invsimpson")
spec_py <- nuee$specnumber(bci_py)
nuee_specnumber <- as.numeric(py_to_r(spec_py$values))
vegan_specnumber <- vegan::specnumber(bci_mat)
test_that("diversity metrics match vegan", {
expect_equal(unname(nuee_shannon), unname(vegan_shannon), tolerance = 1e-6)
expect_equal(unname(nuee_simpson), unname(vegan_simpson), tolerance = 1e-6)
expect_equal(unname(nuee_invsimpson), unname(vegan_invsimpson), tolerance = 1e-6)
})
test_that("species richness matches vegan", {
expect_equal(unname(nuee_specnumber), unname(vegan_specnumber))
})
# -- Distance metrics -------------------------------------------------------------
nuee_dist <- py_to_r(nuee$vegdist(bci_py, method = "bray"))
vegan_dist <- as.matrix(vegan::vegdist(bci_mat, method = "bray"))
test_that("Bray-Curtis distances match vegan", {
expect_equal(unname(nuee_dist), unname(vegan_dist), tolerance = 1e-6)
})
# -- Constrained ordination: RDA --------------------------------------------------
varespec_mat <- as.matrix(varespec_r)
varechem_py  <- nuee$datasets$varechem()
varechem_r   <- py_to_r(varechem_py)
varechem_df  <- as.data.frame(varechem_r)
env_vars <- c("N", "P", "K", "Ca", "Mg")
env_matrix <- as.matrix(varechem_df[, env_vars])
nuee_rda <- nuee$rda(varespec_py, formula = "~ N + P + K + Ca + Mg", data = varechem_py)
vegan_rda <- vegan::rda(varespec_mat, env_matrix)
nuee_rda_eig <- as.numeric(py_to_r(nuee_rda$constrained_eig))
vegan_rda_eig <- as.numeric(vegan_rda$CCA$eig)
test_that("RDA eigenvalues comparable", {
expect_equal(nuee_rda_eig[seq_along(vegan_rda_eig)], vegan_rda_eig, tolerance = 5e-2)
})
test_that("RDA constrained axes available", {
expect_gte(ncol(as.matrix(py_to_r(nuee_rda$points))), length(vegan_rda_eig))
})
for (scaling in 1:3) {
nuee_sites <- as.matrix(py_to_r(nuee_rda$get_scores(display = "sites", scaling = scaling)))
vegan_sites <- vegan::scores(vegan_rda, display = "sites", scaling = scaling)
n_axes <- ncol(vegan_sites)
test_that(paste0("RDA site scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_sites[, seq_len(n_axes), drop = FALSE], vegan_sites, tolerance = 1e-1)
})
nuee_species <- as.matrix(py_to_r(nuee_rda$get_scores(display = "species", scaling = scaling)))
vegan_species <- vegan::scores(vegan_rda, display = "species", scaling = scaling)
test_that(paste0("RDA species scores scaling=", scaling, " roughly align"), {
expect_equal(nuee_species[, seq_len(n_axes), drop = FALSE], vegan_species, tolerance = 1e-1)
})
}
# Helper script to export vegan RDA reference values for nuee comparison.
#
# Usage (from repo root in R):
#   source("tests/reference/export_vegan_rda.R")
#
# The script writes a single RDS file containing the raw decomposition
# pieces (CCA/C A bases, eigenvalues, weights) and the scaled site/species
# scores for scaling 1/2/3. nuee can then load the RDS to compare its
# Python outputs axis-by-axis without relying on string parsing.
library(vegan)
data(varespec)
data(varechem)
env_vars <- c("N", "P", "K", "Ca", "Mg")
vegan_rda <- vegan::rda(varespec, varechem[, env_vars])
# Collect raw SVD components / weights
reference <- list(
eigenvalues = list(
constrained = vegan_rda$CCA$eig,
unconstrained = vegan_rda$CA$eig
),
bases = list(
cca_wa = vegan_rda$CCA$wa,
ca_u = vegan_rda$CA$u,
cca_v = vegan_rda$CCA$v,
ca_v = vegan_rda$CA$v
),
weights = list(
row_sums = vegan_rda$rowsum,
col_sums = vegan_rda$colsum
),
totals = list(
tot_chi = vegan_rda$tot.chi,
colsum = vegan_rda$colsum,
rownames = rownames(vegan_rda$CCA$wa),
colnames = colnames(vegan_rda$CCA$v)
),
scores = list(
scaling1 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 1),
species = vegan::scores(vegan_rda, display = "species", scaling = 1)
),
scaling2 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 2),
species = vegan::scores(vegan_rda, display = "species", scaling = 2)
),
scaling3 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 3),
species = vegan::scores(vegan_rda, display = "species", scaling = 3)
)
)
)
dir.create("tests/reference", showWarnings = FALSE, recursive = TRUE)
saveRDS(reference, file = "tests/reference/vegan_rda_reference.rds")
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.rds\n")
# Helper script to export vegan RDA reference values for nuee comparison.
#
# Usage (from repo root in R):
#   source("tests/reference/export_vegan_rda.R")
#
# The script writes a single RDS file containing the raw decomposition
# pieces (CCA/C A bases, eigenvalues, weights) and the scaled site/species
# scores for scaling 1/2/3. nuee can then load the RDS to compare its
# Python outputs axis-by-axis without relying on string parsing.
library(vegan)
library(jsonlite)
data(varespec)
data(varechem)
env_vars <- c("N", "P", "K", "Ca", "Mg")
vegan_rda <- vegan::rda(varespec, varechem[, env_vars])
# Collect raw SVD components / weights
reference <- list(
eigenvalues = list(
constrained = vegan_rda$CCA$eig,
unconstrained = vegan_rda$CA$eig
),
bases = list(
cca_wa = vegan_rda$CCA$wa,
ca_u = vegan_rda$CA$u,
cca_v = vegan_rda$CCA$v,
ca_v = vegan_rda$CA$v
),
weights = list(
row_sums = vegan_rda$rowsum,
col_sums = vegan_rda$colsum
),
totals = list(
tot_chi = vegan_rda$tot.chi,
colsum = vegan_rda$colsum,
rownames = rownames(vegan_rda$CCA$wa),
colnames = colnames(vegan_rda$CCA$v)
),
scores = list(
scaling1 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 1),
species = vegan::scores(vegan_rda, display = "species", scaling = 1)
),
scaling2 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 2),
species = vegan::scores(vegan_rda, display = "species", scaling = 2)
),
scaling3 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 3),
species = vegan::scores(vegan_rda, display = "species", scaling = 3)
)
)
)
dir.create("tests/reference", showWarnings = FALSE, recursive = TRUE)
saveRDS(reference, file = "tests/reference/vegan_rda_reference.rds")
write_json(reference, path = "tests/reference/vegan_rda_reference.json", digits = NA, auto_unbox = TRUE)
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.rds\n")
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.json\n")
# Helper script to export vegan RDA reference values for nuee comparison.
#
# Usage (from repo root in R):
#   source("tests/reference/export_vegan_rda.R")
#
# The script writes a single RDS file containing the raw decomposition
# pieces (CCA/C A bases, eigenvalues, weights) and the scaled site/species
# scores for scaling 1/2/3. nuee can then load the RDS to compare its
# Python outputs axis-by-axis without relying on string parsing.
library(vegan)
library(jsonlite)
data(varespec)
data(varechem)
env_vars <- c("N", "P", "K", "Ca", "Mg")
vegan_rda <- vegan::rda(varespec, varechem[, env_vars])
# Collect raw SVD components / weights
reference <- list(
eigenvalues = list(
constrained = vegan_rda$CCA$eig,
unconstrained = vegan_rda$CA$eig
),
bases = list(
cca_wa = vegan_rda$CCA$wa,
ca_u = vegan_rda$CA$u,
cca_v = vegan_rda$CCA$v,
ca_v = vegan_rda$CA$v
),
weights = list(
row_sums = vegan_rda$rowsum,
col_sums = vegan_rda$colsum
),
totals = list(
tot_chi = vegan_rda$tot.chi,
colsum = vegan_rda$colsum,
rownames = rownames(vegan_rda$CCA$wa),
colnames = colnames(vegan_rda$CCA$v)
),
scores = list(
scaling1 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 1),
species = vegan::scores(vegan_rda, display = "species", scaling = 1)
),
scaling2 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 2),
species = vegan::scores(vegan_rda, display = "species", scaling = 2)
),
scaling3 = list(
sites = vegan::scores(vegan_rda, display = "sites", scaling = 3),
species = vegan::scores(vegan_rda, display = "species", scaling = 3)
)
)
)
dir.create("tests/reference", showWarnings = FALSE, recursive = TRUE)
saveRDS(reference, file = "tests/reference/vegan_rda_reference.rds")
write_json(reference, path = "tests/reference/vegan_rda_reference.json", digits = NA, auto_unbox = TRUE)
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.rds\n")
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.json\n")
# Helper script to export vegan RDA reference values for nuee comparison.
#
# Usage (from repo root in R):
#   source("tests/reference/export_vegan_rda.R")
#
# The script writes a single RDS file containing the raw decomposition
# pieces (CCA/C A bases, eigenvalues, weights) and the scaled site/species
# scores for scaling 1/2/3. nuee can then load the RDS to compare its
# Python outputs axis-by-axis without relying on string parsing.
library(vegan)
library(jsonlite)
data(varespec)
data(varechem)
env_vars <- c("N", "P", "K", "Ca", "Mg")
vegan_rda <- vegan::rda(varespec, varechem[, env_vars])
# Collect raw SVD components / weights
matrix_payload <- function(mat) {
list(
data = unname(as.matrix(mat)),
rownames = if (!is.null(rownames(mat))) rownames(mat) else NULL,
colnames = if (!is.null(colnames(mat))) colnames(mat) else NULL
)
}
reference <- list(
eigenvalues = list(
constrained = unname(vegan_rda$CCA$eig),
unconstrained = unname(vegan_rda$CA$eig)
),
bases = list(
cca_wa = matrix_payload(vegan_rda$CCA$wa),
ca_u = matrix_payload(vegan_rda$CA$u),
cca_v = matrix_payload(vegan_rda$CCA$v),
ca_v = matrix_payload(vegan_rda$CA$v)
),
weights = list(
row_sums = unname(vegan_rda$rowsum),
col_sums = unname(vegan_rda$colsum)
),
totals = list(
tot_chi = vegan_rda$tot.chi
),
scores = list(
scaling1 = list(
sites = matrix_payload(vegan::scores(vegan_rda, display = "sites", scaling = 1)),
species = matrix_payload(vegan::scores(vegan_rda, display = "species", scaling = 1))
),
scaling2 = list(
sites = matrix_payload(vegan::scores(vegan_rda, display = "sites", scaling = 2)),
species = matrix_payload(vegan::scores(vegan_rda, display = "species", scaling = 2))
),
scaling3 = list(
sites = matrix_payload(vegan::scores(vegan_rda, display = "sites", scaling = 3)),
species = matrix_payload(vegan::scores(vegan_rda, display = "species", scaling = 3))
)
)
)
dir.create("tests/reference", showWarnings = FALSE, recursive = TRUE)
saveRDS(reference, file = "tests/reference/vegan_rda_reference.rds")
write_json(reference, path = "tests/reference/vegan_rda_reference.json", digits = NA, auto_unbox = TRUE)
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.rds\n")
cat("Wrote vegan RDA reference to tests/reference/vegan_rda_reference.json\n")
quit()
